const jsonfile = require('jsonfile');
const path = require('path');
const { sendJSON, getBody } = require('./utilities');

// Local text file will hold the list of favorite quotes.
//
const favoritesFile = path.join(__dirname, 'favorites.json');

// Utility goes through the quotes in the given quotes array and determines the next available id
// that can be used.
//
function nextId(quotes)
{
  return quotes.reduce((high, curr) => (curr.id > high) ? curr.id : high, 0) + 1;
};

// Send the list of favorite quotes back in the body of the given response.
//
exports.sendFavorites = (req, res) =>

  jsonfile.readFile(favoritesFile, (err, quotes) => {
    if (err) {
      sendJSON(res, 200, []);
    } else {
      sendJSON(res, 200, quotes);
    }
  });

// Parse a quote object from the request body and add the new quote to the favorites file.
//
exports.addFavorite = (req, res) =>

  getBody(req, (err, body) => {
    if (err) {
      sendJSON(res, 500, { error : 'writing favorites data' });
    } else {
      const quoteObj = JSON.parse(body);
      if (!quoteObj.quote || !quoteObj.film) {
        sendJSON(res, 400, { error : 'invalid quote' });
      } else {
        jsonfile.readFile(favoritesFile, (err, quotes) => {
          quotes = quotes || [];
          if (quotes.find((q) => (q.quote == quoteObj.quote && q.film == quoteObj.film))) {
            sendJSON(res, 400, { error : 'already a favorite quote' });
          } else {

            // Note that in this sample we add a third property to the quote object and
            // that is a unique id generated by our new utility. This id may optionally
            // then be used to delete the quote from the favorites list.
            //
            quoteObj.id = nextId(quotes);

            quotes.push(quoteObj);
            jsonfile.writeFile(favoritesFile, quotes, { spaces : 2 }, (err) => {
              if (err) {
                sendJSON(res, 500, { error : 'writing favorites data' });
              } else {
                sendJSON(res, 201, quoteObj);
              }
            });
          }
        });
      }
    }
  });

// Called to process a DELETE request in order to delete a quote from the favorites list. The
// quote to delete is specified by index and that index comes in the form of a query parameter.
// Query parameters are added right onto the url string as follows:
//
//   /favorite-quotes?id=3
//
exports.deleteFavorite = (req, res) => {

  // Just as we did in the main file, we need to create a URL object based on the incoming url
  // in order to parse the various parts out of the url in the incoming request. In the main
  // file, we did this to separate the route from the query parameters so that we could branch
  // based on the route. Here we're interested in the query parameters. Consider the following
  // url:
  //
  //   http://www.mydomain.com/favorite-quotes?first=one&second=two&third=three
  //
  // After creating the URL oject, we can reference the "searchParams" property which is an
  // object of type URLSearchParams representing the query parameters. From there we can use
  // the ".get" method on that object to fetch query parameters by name. Here we are interested
  // in the query parameter named "id" so we reference that using "url.searchParams.get('id')".
  //
  const url = new URL(req.url, `http://${req.headers.host}/`);

  // Now that we have the URL object, we can fetch the id propery from the object's searchParams
  // object. Note here that the use of "parseInt" on the id (which is a string) will result in
  // NaN should any error occur. That includes passing a value other than a number or not specifying
  // the "id" parameter at all.
  //
  const id = parseInt(url.searchParams.get('id'));

  // Send back an error if we couldn't parse the id.
  //
  if (isNaN(id)) {
    sendJSON(res, 400, { error : 'bad id specification' });

  // Assuming we parsed a good index from the query parameter, we have to use it to remove the quote
  // from the file. Read the entirety of the file into memory and send back an error if there is a
  // problem reading the file.
  //
  } else {
    jsonfile.readFile(favoritesFile, (err, quotes) => {
      if (err) {
        sendJSON(res, 500, { error : 'reading favorites file' });
      } else {

        // Locate the index of the item in the array whose id matches the id specified in the
        // query parameters.
        //
        const ix = quotes.findIndex((quoteObj) => {
          return quoteObj.id === id;
        });

        // If the item wasn't found, return an error response. Otherwise remove that quote from
        // our quotes array and write the entire file back to disk.
        //
        if (ix < 0) {
          sendJSON(res, 400, { error : 'id out of range' });
        } else {
          quotes.splice(ix, 1);
          jsonfile.writeFile(favoritesFile, quotes, { spaces : 2 }, (err) => {
            if (err) {
              sendJSON(res, 500, { error : 'writing favorites data' });
            } else {
              sendJSON(res, 200, { message : 'Quote successfully removed' });
            }
          });
        }
      }
    });
  }
};
